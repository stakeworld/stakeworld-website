"use strict";(self.webpackChunkstakeworld_io=self.webpackChunkstakeworld_io||[]).push([[770],{4948:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"validate/disaster","title":"Disaster managment","description":"How to maintain a working node when there are problems","source":"@site/docs/validate/disaster.mdx","sourceDirName":"validate","slug":"/disaster","permalink":"/docs/disaster","draft":false,"unlisted":false,"editUrl":"https://github.com/stakeworld/website/edit/master/docs/validate/disaster.mdx","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"disaster","title":"Disaster managment","description":"How to maintain a working node when there are problems","slug":"/disaster","sidebar_position":5,"keywords":["validator setup","validator","validate","polkadot","kusama"]},"sidebar":"tutorialSidebar","previous":{"title":"Monitoring a validator node","permalink":"/docs/monitor"},"next":{"title":"Using a Ledger Wallet","permalink":"/docs/ledger"}}');var i=n(4848),s=n(8453);const a={id:"disaster",title:"Disaster managment",description:"How to maintain a working node when there are problems",slug:"/disaster",sidebar_position:5,keywords:["validator setup","validator","validate","polkadot","kusama"]},r=void 0,d={},l=[{value:"Using backup nodes",id:"using-backup-nodes",level:2},{value:"Chilling nodes",id:"chilling-nodes",level:2}];function h(e){const o={admonition:"admonition",h2:"h2",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(o.p,{children:"When running a validator node it is important to have an action plan in place when there are problems with your node. For example you node server goes down, or a database gets corrupted."}),"\n",(0,i.jsx)(o.h2,{id:"using-backup-nodes",children:"Using backup nodes"}),"\n",(0,i.jsx)(o.p,{children:"Preferably you continue your validating actions with minimum downtime. The quickest and most dangerous option is to start another node with the same session keys. The danger being that running two validator nodes with the same session key is a no go and considered ground for slashing your validator. So this option is only possible when you have access to the original node, can disable the failing node and preferably delete the session keys there so there is no room for double signing."}),"\n",(0,i.jsx)(o.p,{children:"If for example there is a network outage, you would start a new node with the same session keys and the original node would recover, you would be having two nodes active with the same session keys."}),"\n",(0,i.jsx)(o.h2,{id:"chilling-nodes",children:"Chilling nodes"}),"\n",(0,i.jsx)(o.p,{children:"The other options are chilling your node (taking it out of the validator pool) or create new session keys and link them to your stash. Both have disadvantages, for example when you link new session keys it takes two full sessions before the change is propagated, in the meanwhile you validator is down and could be chilled by the system."}),"\n",(0,i.jsx)(o.admonition,{type:"info",children:(0,i.jsx)(o.p,{children:"stakeworld keeps a backup node with backup session keys available so that if a node fails we can quickly continue validating. If there is the risk of double signing (no access to the original node) we will chill the node if there is no other option to avoid slashing"})})]})}function c(e={}){const{wrapper:o}={...(0,s.R)(),...e.components};return o?(0,i.jsx)(o,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>a,x:()=>r});var t=n(6540);const i={},s=t.createContext(i);function a(e){const o=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(s.Provider,{value:o},e.children)}}}]);