"use strict";(self.webpackChunkstakeworld=self.webpackChunkstakeworld||[]).push([[494],{3905:(e,t,r)=>{r.d(t,{Zo:()=>l,kt:()=>h});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),p=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},l=function(e){var t=p(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),d=p(r),h=o,m=d["".concat(c,".").concat(h)]||d[h]||u[h]||a;return r?n.createElement(m,s(s({ref:t},l),{},{components:r})):n.createElement(m,s({ref:t},l))}));function h(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,s=new Array(a);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var p=2;p<a;p++)s[p]=r[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},2213:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var n=r(3117),o=(r(7294),r(3905));const a={slug:"RPC node setup",title:"RPC node setup",authors:"stakeworld"},s=void 0,i={permalink:"/blog/RPC node setup",editUrl:"https://github.com/stakeworld/website/edit/master/blog/rpc-findings.md",source:"@site/blog/rpc-findings.md",title:"RPC node setup",description:"RPC node setup",date:"2022-12-09T10:09:44.000Z",formattedDate:"December 9, 2022",tags:[],readingTime:2.215,hasTruncateMarker:!1,authors:[{name:"Stakeworld",title:"Maintainer of Stakeworld",url:"https://github.com/stakeworld",imageURL:"https://github.com/stakeworld.png",key:"stakeworld"}],frontMatter:{slug:"RPC node setup",title:"RPC node setup",authors:"stakeworld"}},c={authorsImageUrls:[void 0]},p=[{value:"RPC node setup",id:"rpc-node-setup",level:2},{value:"Secure Websocket",id:"secure-websocket",level:2},{value:"Archive node vs pruned node",id:"archive-node-vs-pruned-node",level:3},{value:"Secure the RPC server",id:"secure-the-rpc-server",level:3},{value:"Secure the ws port",id:"secure-the-ws-port",level:3},{value:"Using apache2 for proxying",id:"using-apache2-for-proxying",level:4},{value:"Stress testing your server",id:"stress-testing-your-server",level:3}],l={toc:p};function u(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"rpc-node-setup"},"RPC node setup"),(0,o.kt)("p",null,"Stakeworld has recently setup public rpc nodes for polkadot and kusama, which will hopefully soon be included in the polkadot.js UI. Below some of the lessons learned in the process that might be interesting for others."),(0,o.kt)("h2",{id:"secure-websocket"},"Secure Websocket"),(0,o.kt)("p",null,"To access the polkadot, kusama and parachains network we need some kind of entry in the network. This can be achieved by ",(0,o.kt)("a",{parentName:"p",href:"docs/validate"},"setting up a node")," which has sa RPC server and allowing access to that RPC server via a secure websocket (wss) port. The default setup already exposes a non secure ws socket on port 9944, but for a more usable situation we need a secure websocket which is accesible through a public port."),(0,o.kt)("h3",{id:"archive-node-vs-pruned-node"},"Archive node vs pruned node"),(0,o.kt)("p",null,"A pruned node knows only the recent information about the network and not its full history. Most frequently done actions can be done with a pruned node, for example see account balances, make transfers, setup session keys, staking, etc. An archive node has the full history (database) of the network a can be queried in all kind of ways, give information about transfers since the network started, historical balances, advances queries about past events, etc. "),(0,o.kt)("p",null,"An archive node requires a lot more diskspace (see ","[the snapshot page]","(docs/snapshots] for pruned and archive db sizes). Inclusion in the Polkadot.js UI requires an archive node. For an archive node you need the options ",(0,o.kt)("inlineCode",{parentName:"p"},"--state-pruning archive --blocks-pruning archive")," in your startup settings. "),(0,o.kt)("h3",{id:"secure-the-rpc-server"},"Secure the RPC server"),(0,o.kt)("p",null,"You can choose ",(0,o.kt)("strong",{parentName:"p"},"what")," to expose with ",(0,o.kt)("strong",{parentName:"p"},"how many")," connections ",(0,o.kt)("strong",{parentName:"p"},"from where")," through your rpc server."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"How many"),": You can set your maximum connections throug ",(0,o.kt)("inlineCode",{parentName:"p"},"--ws-max-connections"),", for example ",(0,o.kt)("inlineCode",{parentName:"p"},"--ws-max-connections 100")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"From where"),": by default localhost and the polkadot.js are allowed to access the RPC server, you can change this by setting ",(0,o.kt)("inlineCode",{parentName:"p"},"--rpc-cors"),", to allow access from everywhere you need ",(0,o.kt)("inlineCode",{parentName:"p"},"--rpc-cors all")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"What:"),": you can limit the methods to use with ",(0,o.kt)("inlineCode",{parentName:"p"},"--rpc-methods"),", an easy way to set this to a safe mode is ",(0,o.kt)("inlineCode",{parentName:"p"},"--rpc-methods Safe")),(0,o.kt)("h3",{id:"secure-the-ws-port"},"Secure the ws port"),(0,o.kt)("p",null,"The ws port is a way to access the RPC server and preferably when exposed from the outside is secured with a SSL certificate."),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.polkadot.network/docs/maintain-wss"},"polkadot wiki")," already covers a lot of information about this, especially in relation to setting it up in a nginx configuration. I've focussed more on a apache2 but principles are the same. The main principle in converting the non secure ws port to a secure wss port is putting in behind a proxy. So from outside one see's the SSL enabled apache2/nginx/other proxy server, witch redirect the request to the internal node."),(0,o.kt)("h4",{id:"using-apache2-for-proxying"},"Using apache2 for proxying"),(0,o.kt)("h3",{id:"stress-testing-your-server"},"Stress testing your server"))}u.isMDXComponent=!0}}]);